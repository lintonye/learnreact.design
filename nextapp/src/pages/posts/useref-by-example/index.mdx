import { ConvertKitForm } from '@/components/design-system'
export const meta = {
  title: 'useRef By Example',
  description: `React is a JavaScript library for building user interfaces. This is the official definition of React. But what if you are not familiar with JavaScript? What if you are not a developer? Would you still be able to make sense of (and learn) React? My answer is a firm YES. `,
  date: '2021-02-25',
  tags: ['react'],
  related: ['what-is-react-native', 'what-is-redux'],
  ogImage: {
    // url: imgSocialCard,
    width: 1280,
    height: 720,
  },
  // surprise: {
  //   actor: () => <Image src={imgSurprise} width={145} height={145} />,
  //   animationVariants: {
  //     hidden: { x: -10, rotate: 0, y: 40 },
  //     revealed: { x: -150, rotate: 0, y: 40 },
  //   },
  // },
}

<!--excerpt-->

"React is a JavaScript library for building user interfaces." This is the official definition. But what if you are not familiar with JavaScript? Would you still be able to make sense of (and learn) React? My answer is a firm YES.

<!--/excerpt-->

## Introduction

`useRef` is a built-in React Hook. It is, at least in my experience, one of the most confusing Hooks (perhaps right after `useEffect`)(agree? +1 TODO). But it's actually a hidden gem ðŸ’Ž. With a good understanding of how it works, it'll become a powerful tool in our arsenal.

What is `useRef` used for? There are two use cases:

1. **Directly access DOM nodes.** When combined with the `ref` attribute, we could use `useRef` to obtain the underlying DOM nodes to perform DOM operations imperatively. In fact, we should only do this sparsely for things like setting focus, measuring DOM nodes or animations. If we use it for everything (in theory we could), we'd lose the benefit of [React's declarative programming paradigm](TODO).
2. **Persist values across re-renders.** This is what I'm going to focus on in this article.

I'll reveal this shiny gem <span className="mr-2">ðŸ’Ž</span> for you in three steps: 1) how it works, 2) a couple of simple examples, and finally 3) a real-world example -- the like button below (click and hold for additional fun).

TODO like button

## The mental model

> `useRef` is like class instance variable for function components.

This single sentence is what made `useRef` click for me. If it has the same effect on you, feel free to skip to [the examples section](TODO). Otherwise, if you are not familiar JavaScript classes or class instance variables, read on.

### The recurring rendering cycles

To understand how `useRef` works and why we need it, let's get started with a contrived (but useful) example. Can you build a counter without using the `useState` hook?

Let's give it a try:

```jsx
function Counter() {
  let count = 0
  return (
    <div>
      <div>{count}</div>
      <button
        onClick={() => {
          count++
          console.log(count)
        }}
      >
        +1
      </button>
    </div>
  )
}
```

This doesn't work, even though the value of `count` increases on click. Why? React is oblivious to the change of local variables and, therefore, doesn't know when to update the DOM. We'd need to re-render the component, namely request React to call the component function, to notify React about the change.

This can be verified by adding a line `console.log('render')` right after `let count = 0`.

OK. Then what if we force the component to render when `count` updates?

```jsx
function Counter() {
  const forceRender = useForceRender()
  let count = 0
  return (
    <div>
      <div>{count}</div>
      <button
        onClick={() => {
          count++
          console.log(count)
          forceRender()
        }}
      >
        +1
      </button>
    </div>
  )
}

// I know, I used useState below. Didn't I say the example was contrived? :)
function useForceRender() {
  const setC = useState(0)[1]
  return () => setC((c) => c + 1)
}
```

This doesn't work either. The count displayed on the page stays zero. Even worse, the count value in the console stopped working too. It's always `1`!

Why? Every time when the component re-renders, it goes into a time loop. All the local variables in the function will be reset to their original values. That's why `count` is always `0`. That's no surprise, right? They are local variables defined in the function. When the function reruns, the variables are supposed to behave like that!

As straighforward this sounds, sometimes it's easy to forget it (I do it all the time). So remember, in React a component is re-rendered all the time, so all the local variables will go into a time loop, over and over again.

Now what if we move the variable out of the component function? It will no longer reset no matter how many times the component is rendered, right?

```jsx
let count = 0
function Counter() {
  const forceRender = useForceRender()
  return (
    <div>
      <div>{count}</div>
      <button
        onClick={() => {
          count++
          forceRender()
        }}
      >
        +1
      </button>
    </div>
  )
}
```

That's correct! It works! Yay!

But wait a second, what if we want to have two counters? Or maybe three?

```jsx
function TwoCounters() {
  return (
    <div>
      <Counter />
      <Counter />
    </div>
  )
}
```

So looks like our counters break again. That's because both counters are tied to the same variable `count`. What we need instead is to have a **_separate_** variable for each **_instance_** of the counter.

Introducing `useRef`!

```jsx
function Counter() {
  const forceRender = useForceRender()
  /* 1. Get a "variable" that corresponds to the CURRENT INSTANCE of the component */
  let count = useRef(0)
  return (
    <div>
      {/* 2. Use the value stored inside the "variable" */}
      <div>{count.current}</div>
      <button
        onClick={() => {
          /* 3. Update the value of the "variable" */
          count.current = count.current + 1
          forceRender()
        }}
      >
        +1
      </button>
    </div>
  )
}
```

But, but we are still using that `useForceRender` to update the DOM! What's the point o

Why do we need `useRef`? Why don't we just use `useState`? The answer is that sometimes we don't want to trigger re-render.

Whenever a component is re-rendered, it goes into a time loop.

A very forgetive person. So we would need a note book (hook) to help him remember important things.

### Component instance

ref attribute

Class: instance variable

compare with useState: Persist value across re-renders, doesn't trigger re-render

An illustration
usually use with useEffect

### `useRef` vs. `useState`

### `useRef` vs. `createRef`

<div className="p-8 bg-yellow-100 border border-yellow-400 rounded-sm space-y-4 my-2">
  <p>
    I'm working on a book/course that uses similar approach to teach React -- focus on mental models instead of steps and howtos.
    focus on why, not just how.
  </p>
  <p>
    I believe you'd be able to do useful work with React after a few days of
    learning, <strong>even if you are new to coding</strong>. If you are interested, sign
    up and I'll let you know when the course is ready!
  </p>

  <ConvertKitForm formId="467678" subscribeButtonTitle="Keep Me Posted" />
</div>

### `ref` and `useRef`

As mentioned, we could use the `ref` attribute and `useRef` to obtain the access to underlying DOM nodes, like so:

```jsx
function Editor() {
  /* 1. Call useRef */
  const textboxRef = useRef()
  return (
    <div>
      {/* 2. "Bind" the ref with the input */}
      <input type="text" ref={textboxRef} />
      <button
        onClick={() => {
          /* 3. Access the DOM node via ref.current */
          textboxRef.current.focus()
        }}
      >
        Focus
      </button>
    </div>
  )
}
```

But, have you wondered how it works?

From what it looks, `textboxRef` is simply an object with a single property `current`. React receives this object via the `ref` attribute of `input` and mutates it at some point:

```jsx
// Imaginary React code
ref.current = domNode
```

This is roughly what's going on. But to understand why we'd need this approach instead of, for example, using a global variable somewhere, let's check out the rendering cycle of React components.

## Example 1: previous value / state

```jsx
function Counter() {
  const [count, setCount] = useState(0)
  const prevCount = useRef()
  useEffect(() => {
    prevCount.current = count
  })

  return (
    <div className="App">
      <h1>
        Prev:{prevCount.current}, Count: {count}
      </h1>
      <button onClick={() => setCount((c) => c + 1)}>+1</button>
    </div>
  )
}
```

https://codesandbox.io/s/useref-previous-state-hmthe

## Example 2: stop watch (clear interval)

https://codesandbox.io/s/useref-cancelable-interval-uljky?file=/src/App.js

## Example 3: usePressHoldRepeat

https://codesandbox.io/s/useref-usepressholdrepeat-7megx

## Example 4: useDebouncedState

## Anti-patterns

assign to current in render
use current in jsx

## Misc.

"What is the difference between useRef and createRef?"

## Conclusion

When combined with `useEffect`, `useState` and `useCallback`, `useRef` turns out to be a powerful tool.
Other examples? Let me know
