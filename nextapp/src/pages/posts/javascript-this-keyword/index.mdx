import { ConvertKitForm } from '@/components/design-system'
import { LiveEditor, CodeViewer } from '@/components/LiveEditor'
import { useForceRender } from '@/components/useref-by-example/useForceRender'
// import { UseRefSurprise } from '@/components/useref-by-example/UseRefSurprise'
// import { Demo } from '@/components/Demo'
import { Reactions } from '@/components/Reactions'
import { NoticeBox } from '@/components/NoticeBox'
// import imgTimeLoop from './time-loop.jpeg'
// import imgSocialCard from './useref-social-card.png'
import { FiInfo } from 'react-icons/fi'
import { Quiz } from '@/components/Quiz'

export const meta = {
  title: `"this" Is Weird: Understanding JavaScript "this" Keyword`,
  description: `The React.useRef Hook is used for referencing DOM nodes and persisting a mutalbe value across rerenders. This is an interactive guide to useRef with real-world examples.`,
  date: '2021-04-10',
  tags: ['javascript'],
  related: [
    'react-mental-model-cut-holes-in-html-template',
    'react-mental-model-html-input',
    'react-mental-model-jsx',
  ],
  ogImage: {
    // url: imgSocialCard,
    width: 1280,
    height: 720,
  },
  // surprise: {
  //   actor: (revealEnded) => <UseRefSurprise autoPlay={revealEnded} />,
  //   animationVariants: {
  //     hidden: { x: 0, rotate: 0, y: 60 },
  //     revealed: { x: -100, rotate: 0, y: 60 },
  //   },
  // },
}

<!--excerpt-->

The `this` keyword in JavaScript behaves differently than similar constructs in other languages.

<!--/excerpt-->

The `this` keyword is a fundamental concept in JavaScript. However its behavior may appear very strange, especially if you are familiar with similar constructs in other languages, for example `this` in Java, or `self` in Python or Ruby [^1].

Take this React class component [^2] as an example:

```jsx
class MyComponent {
  constructor() {
    this.state = { count: 0 }
  }
  handleClick() {
    this.setState({ count: count + 1 })
  }
  render() {
    return <button onClick={this.handleClick}>{count}</button>
  }
}
```

This code displays a counter on a button. It looks fine, right? But if you click the button, you'll get an error:

```html
setState is not a function TODO accurate error message
```

Why? Isn't `handleClick` a method of class `MyComponent`? Why is the value of `this` `undefined`? Isn't it supposed to be the current class instance?

**_This is weird!_**

In this post, let's take a quick tour of how `this` works in JavaScript.

[^1]: My own story here. I've been struggled with `this` in JavaScript for so long. That's precisely because I've been working as a Java developer for a few years. You don't know what you don't know.
[^2]: I know, these days we don't write that many class components in React anymore. But it's still useful to understand class components since you'll typically see them in legacy code. Not everyone has the time to rewrite all class components as function components.

<NoticeBox title='Intended audience'>

This article assumes that you are familiar with [React](/posts/components-props-state) [basics](/posts/react-mental-model-cut-holes-in-html-template), as well as how to use the `useState` and `useEffect` hooks.

</NoticeBox>

## `this` is not just for classes

In languages such as Java, the `this` keyword only makes sense inside a class. But in JavaScript, we can use it pretty much everywhere:

```jsx
// Use `this` at the top level, aka global context
console.log(this)
```

Now open the JavaScript console and type in the code above, what did you get?

When used at the top level, also known as the global context, the value of `this` is the `Window` object. It's the default value of `this` [^3].

[^3]: Because JavaScript can run in environments other than a web browser, there's a special keyword, `globalThis` that points to `Window` or another value depending on the environment.

We can also use the `this` keyword in a function, like so:

```jsx
function printThis() {
  console.log(this)
}
```

What would it print out if we call this function? The current instance of ... the function? The `Window` object?

The short answer is: _we don't know yet!_

The longer answer is:

> The value of `this` inside a function depends on _how_ the function is called.

Isn't `this` weird? This is where most confusions come from.

Keep reading ðŸ‘‡.

## `this` is determined at runtime

### Calling a function with a receiving object

Try the code below in the console:

```jsx
function printThis() {
  console.log(this)
}

printThis()
```

In this code, we get the default value of `this`, the `Window` object (in fact it's not always the case, but I'll cover it [later](TODO)).

Now try the code below:

```jsx
// define the function as a property of obj
let obj = {
  printThis: function () {
    console.log(this)
  },
}

obj.printThis()
```

We get the object where the function is defined! Hmm, `this` is interesting.

But it totally makes sense, right? It allows the function to easily access the properties of the object, like so:

```jsx
let car = {
  make: 'Tesla',
  model: '3',
  print: function () {
    console.log(`Make: ${this.make}, Model: ${this.model}`)
  },
}
car.print()
```

We'll get:

```html
Make: Tesla, Model: 3
```

But that's not the end of the story! What if we assign the function to a variable and call it like so:

```jsx
let print = car.print
// call the function without the receiving object
print()
```

We'll get:

```html
Make: undefined, Model: undefined
```

Hmm... Does the function forget about the object where it's defined? `this` is weird!

As I said,

> The value of `this` inside a function depends on _how_ the function is called.

Because we call the `print` function without a receiving object, the value of `this` is `Window`, the default value. It doesn't have properties `make` and `model`.

Now a quick quiz, what do you think will the following code print?

```jsx
let truck = {
  make: 'Tesla',
  model: 'Cybertruck',
}

function print() {
  console.log(`Make: ${this.make}, Model: ${this.model}`)
}

truck.print = print
truck.print()
```

<Quiz
  options={[
    'Make: Tesla, Model: Cybertruck',
    'Make: undefined, Model: undefined',
    'Make: Tesla, Model: undefined',
    'None of the above',
  ]}
  id="js-this-truck-print"
  mb={6}
  answer="B"
  explanation='Since the function is called with the receiving object "truck", the value of "this" inside the function is truck.'
/>

---

The value of `this` inside a function depends on _how_ the function is called, NOT _where_ the function is defined.

Isn't `this` weird?

### The `new` keyword

We could also call a function with the `new` keyword:

```jsx
function Car(make, model) {
  this.make = make
  this.model = model
}
let car = new Car('Tesla', '3')
console.log(car)
```

We'll get:

```html
CarÂ {make: "Tesla", model: "3"}
```

When calling a function with the `new` keyword, we'll get a new object. The value of `this` inside that function equals to the new object.

The following code is equivalent but in the class format:

```jsx
class Car {
  constructor(make, model) {
    // `this` is the new object
    this.make = make
    this.model = model
  }
}
let car = new Car('Tesla', '3')
console.log(car)
```

In fact, the `class` in JavaScript is just syntax sugar. Under the hood, it's just a function.

### Strict mode

As I mentioned before, the default value of `this` isn't always the `Window` object. That's because of the so-called "strict mode".

```jsx
function printThis() {
  // force strict mode
  'use strict'
  console.log(this)
}

printThis()
```

This code will print out `undefined` since in strict mode, the default value of `this` is `undefined`.

We used `"use strict"` to explicitly turn on strict mode. But in some cases, the strict mode is on by default, for example, in a `class`:

```jsx
class Car {
  print() {
    // always in strict mode
  }
}
```

## More ways to change `this` at runtime

So far, I've shown you that the value of `this` depends on how a function is called:

- Did we call the function with a receiving object? i.e. `obj.print()` or just `print()`?
- Did we call the function with the `new` keyword?

But that's actually not the full picture! It turns out that we can specify the value of `this` explicitly.

### `call` and `apply`

We can call any function using `call` or `apply` to specify the value of `this`:

```jsx
anyFunction.call({ msg: 'whatever' })
anyFunction.apply({ msg: 'whatever' })
```

### `bind`

The `bind` method returns a function, which we can call in the same way as the original function. But we can rest assure that the value of `this` is always what we want.

```jsx
function printThis() {
  console.log(this)
}
let print = printThis.bind({ msg: 'I can be whatever object you want!' })
print()
```

The output is:

```html
Object { msg: "I can be whatever object you want!"}
```

`bind` is useful when we don't have control over how a function is called, for example, when passing the function as a callback.

### `bind` always wins

It's worth noting that as long as a function is bound, `this` inside the function remains the bound value. It can no longer be changed via `call` or `apply`.

```jsx
function printThis() {
  console.log(this)
}

let boundFun = printThis.bind(`I'm bound! You can't change my "this"!`!)

boundFun.call('haha')
// Output: I'm bound! You can't change my "this"!

boundFun.call('lala')
// Output: I'm bound! You can't change my "this"!

let obj = {}
obj.printThis = boundFun
obj.printThis()
// Output: I'm bound! You can't change my "this"!
```

## `this` and callback functions

### `this` and `that`

Because of the seemingly strange behavior, we can usually see this pattern.

```jsx
let colours = ['red', 'green', 'blue']
let button = document.getElementById('button')
button.addEventListener('click', function () {
  // `this` is a reference to the element clicked on
  let that = this
  colours.forEach(function () {
    // `this` is the default value, `Window` or `undefined` in strict mode
  })
})
```

## `this` in arrow functions

The keyword `this` behaves differently in arrow functions than normal functions.

```jsx
let car = {
  make: 'Tesla',
  model: '3',
  print: () => {
    console.log(`Make: ${this.make}, Model: ${this.model}`)
  },
}
car.print()
```

## Recap & Back to React class components

Let's get back to the class component example I showed you at the beginning. Do you now understand why we'll get an error when the user clicks the button? Why does the value of `this` is `undefined` inside `handleClick`?

```jsx
class MyComponent {
  constructor() {
    this.state = { count: 0 }
  }
  handleClick() {
    this.setState({ count: count + 1 })
  }
  render() {
    return <button onClick={this.handleClick}>{count}</button>
  }
}
```

Which of the following is NOT the cause of the error?

<Quiz
  options={[
    'The code inside classes is in strict mode.',
    'The function "handleClick" is passed into button and is called without a receiving object.',
    'The default value of "this" inside handleClick is "undefined".',
    'The value of "this" is set to "undefined" after the user clicks the button.',
  ]}
  id="js-this-class-component"
  mb={6}
  answer="D"
  explanation=""
/>

How would we fix the error in the aforementioned class component? How would we make sure the value of `this` in `handleClick` is the current class instance instead of `undefined`? In another word, is there a way to set the value of `this` explicitly?

So, the fix for our class component would be:

```jsx
class MyComponent {
  constructor() {
    this.state = { count: 0 }
    // `this` in the constructor is always the new object just created.
    this.handleClick = this.handleClick.bind(this)
  }
  handleClick() {
    this.setState({ count: count + 1 })
  }
  render() {
    return <button onClick={this.handleClick}>{count}</button>
  }
}
```

---

```jsx
class MyComponent {
  constructor() {
    this.state = { count: 0 }
  }
  handleClick = () => {
    this.setState({ count: count + 1 })
  }
  render() {
    return <button onClick={handleClick}>{count}</button>
  }
}
```
