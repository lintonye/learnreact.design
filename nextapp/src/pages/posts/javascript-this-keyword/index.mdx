import { ConvertKitForm } from '@/components/design-system'
import { LiveEditor, CodeViewer } from '@/components/LiveEditor'
import { useForceRender } from '@/components/useref-by-example/useForceRender'
// import { UseRefSurprise } from '@/components/useref-by-example/UseRefSurprise'
// import { Demo } from '@/components/Demo'
import { Reactions } from '@/components/Reactions'
import { NoticeBox } from '@/components/NoticeBox'
// import imgTimeLoop from './time-loop.jpeg'
// import imgSocialCard from './useref-social-card.png'
import { FiInfo } from 'react-icons/fi'

export const meta = {
  title: `"this" Is Weird: Understanding JavaScript's "this" Keyword`,
  description: `The React.useRef Hook is used for referencing DOM nodes and persisting a mutalbe value across rerenders. This is an interactive guide to useRef with real-world examples.`,
  date: '2021-04-10',
  tags: ['javascript'],
  related: [
    'react-mental-model-cut-holes-in-html-template',
    'react-mental-model-html-input',
    'react-mental-model-jsx',
  ],
  ogImage: {
    // url: imgSocialCard,
    width: 1280,
    height: 720,
  },
  // surprise: {
  //   actor: (revealEnded) => <UseRefSurprise autoPlay={revealEnded} />,
  //   animationVariants: {
  //     hidden: { x: 0, rotate: 0, y: 60 },
  //     revealed: { x: -100, rotate: 0, y: 60 },
  //   },
  // },
}

<!--excerpt-->

The `this` keyword in JavaScript behaves differently than similar constructs in other languages.

<!--/excerpt-->

The `this` keyword is a fundamental concept in JavaScript. However its behavior may appear very strange, especially if you are familiar with similar constructs in other languages, for example `this` in Java, or `self` in Python or Ruby [^1].

Take this React class component[^2] as an example:

```jsx
class MyComponent {
  constructor() {
    this.state = { count: 0 }
  }
  handleClick() {
    this.setState({ count: count + 1 })
  }
  render() {
    return <button onClick={this.handleClick}>{count}</button>
  }
}
```

The code looks fine, right? But if you click the button, you'll get an error:

```html
setState is not a function TODO accurate error message
```

Isn't `handleClick` a method of class `MyComponent`? Why is the value of `this` is `undefined`? Isn't it supposed to be the current class instance?

**_This is weird!_**

In this post, let's take a quick tour of how `this` works in JavaScript, and more importantly, why it works that way (TODO should we cover this?)!

[^1]: My own story here. I've been struggled with `this` in JavaScript for so long. That's precisely because I've been working as a Java developer for a few years. You don't know what you don't know.
[^2]: I know, these days we don't write that many class components in React anymore. But it's still useful to understand class components since you'll typically see them in legacy code. Not everyone has the time to rewrite all class components as function components.

<NoticeBox title='Intended audience'>

This article assumes that you are familiar with [React](/posts/components-props-state) [basics](/posts/react-mental-model-cut-holes-in-html-template), as well as how to use the `useState` and `useEffect` hooks.

</NoticeBox>

## `this` is not just for classes

In languages such as Java, the `this` keyword only makes sense inside a class. But in JavaScript, we can use it pretty much everywhere:

```jsx
// Use `this` at the top level
console.log(this)
```

Now open the JavaScript console and type in the code above, what did you get?

When used at the top level, the value of `this` is the Window object (in fact it's not always the case, but I'll cover it [later](TODO)). Because JavaScript can run in environments other than a web browser, there's a special keyword, `globalThis`, that points to Window or another value depending on the environment.

We can also use the `this` keyword in a function, like so:

```jsx
function printThis() {
  console.log(this)
}
```

What would it print out if we call this function? The current instance of ... the function? The Window object?

The answer is: _we don't know yet!_

> The value of `this` inside a function depends on _how_ the function is called.

Isn't `this` weird? This is where most confusions come from. Keep reading.

## `this` is determined at runtime

Try the code below in the console:

```jsx
function printThis() {
  console.log(this)
}

printThis()
```

What did you get? The Window object again, right?

Now try the code below:

```jsx
// define the function as a property of obj
let obj = {
  printThis: function () {
    console.log(this)
  },
}

obj.printThis()
```

We get the object where the function is defined! Hmm, `this` is interesting.

But it totally makes sense, right? It allows the function to easily access the properties of the object, like so:

```jsx
let car = {
  make: 'Tesla',
  model: '3',
  print: function () {
    console.log(`Make: ${this.make}, Model: ${this.model}`)
  },
}
car.print()
```

```html
Make: Tesla, Model: 3
```

But that's not the end of the story! What if assign the function to a variable and call it, like so:

```jsx
let print = car.print
print()
```

We'll get:

```html
Make: undefined, Model: undefined
```

So the function forgets about the object where it's defined? `this` is weird!

As I said,

> The value of `this` inside a function depends on _how_ the function is called.

Now a quick quiz, what do you think the following code will print?

```jsx
let truck = {
  make: 'Tesla',
  model: 'Cybertruck',
}

function print() {
  console.log(`Make: ${this.make}, Model: ${this.model}`)
}

truck.print = print
truck.print()
```

TODO quiz

The value of `this` inside a function depends on _how_ the function is called, NOT _where_ the function is defined.

Isn't `this` weird?

---

```jsx
class MyComponent {
  constructor() {
    this.state = { count: 0 }
  }
  handleClick = () => {
    this.setState({ count: count + 1 })
  }
  render() {
    return <button onClick={handleClick}>{count}</button>
  }
}
```
